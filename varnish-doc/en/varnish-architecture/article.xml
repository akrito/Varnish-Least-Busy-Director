<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/css" href="../../share/docbook-xml.css"?>
<!DOCTYPE article
 PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
 "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<article lang="en">
  <articleinfo>
    <releaseinfo role="cvs">$Id$</releaseinfo>
    <title>Varnish HTTP Accelerator Architecture</title>
  </articleinfo>

  <section>
    <title>Application structure</title>

    <section>
      <title>Components</title>

      <para>This section lists the major components in Varnish.</para>

      <section>
	<title>Listener</title>

	<para>The Listener monitors the listening socket and accepts
	incoming client connections.  Once the connection is
	established, it is passed to the Accepter.</para>

	<para>The Listener should take advantage of accept filters or
	similar technologies on systems where they are
	available.</para>
      </section>

      <section>
	<title>Accepter</title>

	<para>The Accepter reads an HTTP request from a client
	connection.  It parses the request line and header only to the
	extent necessary to establish well-formedness and determine
	the requested URL.</para>

	<para>The Accepter then queries the Keeper about the status of
	the requested document (identified by its full URL).  If the
	document is present and valid in the cache, the request is
	passed directly to a Sender.  Otherwise, it is passed to a
	Retriever queue.</para>
      </section>

      <section>
	<title>Keeper</title>

	<para>The Keeper manages the document cache. XXX</para>
      </section>

      <section>
	<title>Sender</title>

	<para>The Sender transfers the contents of the requested
	document to the client.  It examines the HTTP request header
	to determine the correct way in which to do this – Range,
	If-Modified-Since, Content-Encoding and other options may
	affect the type and amount of data transferred.</para>

	<para>There may be multiple concurrent Sender threads.</para>
      </section>

      <section>
	<title>Retriever</title>

	<para>The Retriever is responsible for retrieving documents
	from the content servers.  It is triggered either by an
	Accepter trying to satisfy a request for a document which is
	not in the cache, or by the Janitor when a “hot” document is
	nearing expiry.  Either way, there may be a queue of requests
	waiting for the document to arrive; when it does, the
	Retriever passes those requests to a Sender.</para>

	<para>There may be multiple concurrent Retriever
	threads.</para>
      </section>

      <section>
	<title>Janitor</title>

	<para>The Janitor keeps track of the expiry time of cached
	documents and attempts to retrieve fresh copies of documents
	which are soon to expire.</para>
      </section>

      <section>
	<title>Logger</title>

	<para>The Logger keeps logs of various types of events in
	circular shared-memory buffers.  See <xref
	linkend="sect.logging"/> for details.</para>

	<para>It is the responsibility of each module to feed relevant
	log data to the Logger.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Configuration</title>

    <para>Policy is configured in a simple unidirectional (no loops,
    no goto) programming language which is compiled into 'C' and from
    there binary modules which are dlopen'ed by the main Varnish
    process.</para>

    <para>The dl object contains one exported symbol, a pointer to a
    structure which contains a reference count, a number of function
    pointers, a couple of string variables with identifying
    information.</para>

    <para>All access into the config is protected by the reference
    counts.</para>

    <para>Multiple policy configurations can be loaded at the same
    time but only one is the "active configuration".  Loading,
    switching and unloading of policy configurations happen via the
    managment process.</para>

    <para>A global config sequence number is incremented on each
    switch and policy modified object attributes (ttl, cache/nocache)
    are all qualified by the config-sequence under which they were
    calculated and invalid if a different policy is now in
    effect.</para>
  </section>

  <section id="sect.logging">
    <title>Logging</title>

    <para>
    </para>
  </section>

  <section id="sect.invalidation">
    <title>Invalidation</title>

    <para>When a purge request comes in, the regexp is tagged with the
    next generation number and added to the tail of the list of purge
    regexps.</para>

    <para>Before a sender transmits an object, it is checked against
    any purge-regexps which have higher generation number than the
    object and if it matches the request is sent to a fetcher and the
    object purged.</para>

    <para>If there were purge regexps with higher generation to match,
    but they didn't match, the object is tagged with the current
    generation number and moved to the tail of the list.</para>

    <para>Otherwise, the object does not change generation number and
    is not moved on the generation list.</para>

    <para>New Objects are tagged with the current generation number
    and put at the tail of the list.</para>

    <para>Objects are removed from the generation list when
    deleted.</para>

    <para>When a purge object has a lower generation number than the
    first object on the generation list, the purge object has been
    completed and will be removed.  A log entry is written with number
    of compares and number of hits.</para>
  </section>

  <section id="sect.management">
    <title>Management</title>

    <section>
      <title>Management commands</title>

      <itemizedlist>
	<listitem>
	  <para>object_query url -&gt; TTL, size, checksum</para>
	</listitem>
	<listitem>
	  <para>{purge,invalidate} regexp</para>
	</listitem>
	<listitem>
	  <para>object_status url -&gt; object metadata</para>
	</listitem>
	<listitem>
	  <para>load_config filename</para>
	</listitem>
	<listitem>
	  <para>switch_config configname</para>
	</listitem>
	<listitem>
	  <para>list_configs</para>
	</listitem>
	<listitem>
	  <para>unload_config</para>
	</listitem>
	<listitem>
	  <para>freeze 	# stop the clock, freezes the object store</para>
	</listitem>
	<listitem>
	  <para>thaw</para>
	</listitem>
	<listitem>
	  <para>suspend	# stop acceptor accepting new requests</para>
	</listitem>
	<listitem>
	  <para>resume</para>
	</listitem>
	<listitem>
	  <para>stop	# forced stop (exits) varnish process</para>
	</listitem>
	<listitem>
	  <para>start</para>
	</listitem>
	<listitem>
	  <para>restart = "stop;start"</para>
	</listitem>
	<listitem>
	  <para>ping $utc_time -&gt; pong $utc_time</para>
	</listitem>
	<listitem>
	  <para>stats [-mr] -&gt; $data</para>
	</listitem>
	<listitem>
	  <para>zero stats</para>
	</listitem>
	<listitem>
	  <para>help</para>
	</listitem>
      </itemizedlist>

      <para>Cluster only:</para>
      <itemizedlist>
	<listitem>
	  <para>config_contents filename $inline -> compilation messages</para>
	</listitem>
      </itemizedlist>
    </section>
  </section>

  <bibliography>
    <title>References</title>

    <bibliomixed id="RFC2616"/>
  </bibliography>
</article>
