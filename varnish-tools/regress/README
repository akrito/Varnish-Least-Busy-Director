VARNISH REGRESSION TEST FRAMEWORK

This is a regression test framework written in Perl. It is being
tailored to the needs of the Varnish HTTP accelerator.

The framework is based on interpreting a mini-language designed for
this specific purpose. The mini-language expresses test case setups
and conditions to be tested.

The Perl-based interpreter sets up the run-time environment and
executes a "program" written in this mini-language.

The mini-language's grammar can be found in lib/Varnish/Test/Parser.pm
which utilizes the Parse::RecDescent CPAN-module.

The interpreter creates a run-time environment consisting of simulated
clients and servers which live in the main process. In addition, it
forks off a Varnish sub-process through which the clients and servers
send HTTP-traffic. The main process uses a global select(2)-based loop
(using IO::Multiplex) to which all the simulated clients and servers
must relate. Hence, no threading is needed, but disciplined use
sockets (to avoid blocking and other trouble) is required.

When the mini-language is parsed, a tree of Perl-objects is created.
There are classes representing:

  * a server (Varnish::Test::Server)
  * a client (Varnish::Test::Client)
  * an accelerator/Varnish instance (Varnish::Test::Accelerator)
  * a test-case (Varnish::Test::Case)
  * a statement (Varnish::Test::Statement)
  * an expression (Varnish::Test::Expression)
  * a function invocation (Varnish::Test::Invocation)

These classes share some properties which are found
Varnish::Test::Object, most notably the ability to be "executed" and
temporarily paused when the IO::Multiplex-loop needs to transfers
control to another object.

To keep track of execution, all objects have an attribute, "finished",
which tells its parent whether execution has already terminated. In
addition an attribute "return" is used to hold any return value should
the object have a sensible return value to offer (which is the true
for statements, expressions, and function invocations). Before
"finished" is set to true, "return" has no meaning.

The parent will execute its children sequentially, in the same order
as they are defined in the source code.

However, some objects get control back after they are "finished". This
is the case for server objects when they serve requests, which happens
asynchronously to ordinary execution and is orchestrated by the
IO::Multiplex-loop. When the server object has handled the request,
control returns to the original point of execution. Finding that point
is done by skipping past all objects whose "finished"-attribute is
true.

Finally, the notion of scope and variables is taken care of by
functionality provided in the super-class Varnish::Test::Context from
which Varnish::Test::Object inherits.
